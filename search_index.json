[["index.html", "Adatbázisépítés I. - Bevezetés az adatbázisokba 1 Előszó", " Adatbázisépítés I. - Bevezetés az adatbázisokba Ring Orsolya 2025-2026 1 Előszó Ez a tananyag az Adatbázisépítés I. című kurzus első alkalmához készült, amely az ELTE Bölcsészettudományi Kar Levéltár MA szakos hallgatói számára nyújt bevezetést az adatbázis-kezelés alapjaiba. A tananyag célja, hogy a hallgatók: Megismerjék az adatbázisok alapvető fogalmait és típusait Megértsék a különböző adatbázis-típusok közötti különbségeket Képesek legyenek eldönteni, mikor melyik adatbázis-megoldást érdemes használni Elsajátítsák az Excel alapvető használatát adatkezeléshez Megismerjék a levéltári munka és a történeti kutatás adatbázis-kezelési igényeit A tananyag öt fő fejezetre tagolódik: Mi az adatbázis? - Az alapfogalmak tisztázása Adatbázis típusok - Részletes áttekintés Excel vs Access - Döntési kritériumok Excel alapok - Gyakorlati bevezetés Gyakorlati példa - Fondnyilvántartás készítése A fejezetek egymásra épülnek, ezért érdemes sorrendben haladni Minden fejezet végén ellenőrző kérdések találhatóak A gyakorlati példákat érdemes kipróbálni saját gépen is! Verzió: 1.0 "],["mi-az-adatbázis.html", "2 Mi az adatbázis? 2.1 Alapfogalmak 2.2 Miért van szükség adatbázisokra? 2.3 Adatbázisok a levéltári munkában 2.4 Az adatbázisok fejlődése 2.5 Ellenőrző kérdések 2.6 Következő fejezet", " 2 Mi az adatbázis? 2.1 Alapfogalmak Adatbázis: Strukturáltan tárolt, egymással kapcsolatban lévő adatok összessége, amelyek egy meghatározott célra szervezve, elektronikusan vannak tárolva. Az adatbázis definíciójában három kulcsfogalmat kell kiemelni: 2.1.1 Strukturáltság Az adatok nem összevissza, hanem rendezett formában, meghatározott szabályok szerint vannak elrendezve. Ez azt jelenti, hogy: Minden adatnak megvan a helye a rendszerben Az adatok típusa előre definiált (szöveg, szám, dátum, stb.) Az adatok kapcsolatai logikusan szervezettek Az elérés szabályozott és gyors Példa: Egy levéltári fond adatai nem egyszerűen felsorolásban szerepelnek, hanem strukturált mezőkben: jelzet, megnevezés, időkör, terjedelem, stb. 2.1.2 Tárolás Az adatok elektronikusan, tartósan őrődnek meg, és bármikor visszakereshetők. A tárolás jellemzői: Tartósság: Az adatok nem vesznek el (backup rendszerek) Gyorsaság: Gyors hozzáférés akár nagy mennyiségű adathoz is Biztonság: Jogosultságok, titkosítás Konzisztencia: Az adatok egységesek 2.1.3 Kapcsolatok Az adatok között logikai kapcsolatok vannak, összetartoznak, egymásra hivatkoznak. Például: Egy kutató több látogatást tehet Egy látogatás során több fondotból kérhet iratokat Egy fond több dobozból áll Egy dobozban több irat van Ezek a kapcsolatok nem véletlenszerűek, hanem a valós világ struktúráját tükrözik. 2.2 Miért van szükség adatbázisokra? 2.2.1 Nagy adatmennyiség kezelése Levéltári példa: 500 dobozos fond, benne kb. 20.000 irat. Hogyan tartjuk nyilván? Hogyan keresünk benne? Hagyományos megoldások: - Papír alapú leltárkönyv: Nehéz keresni, lassú, nem lehet rendezni - Word dokumentum: Nincs rendezés, szűrés, nehézkes keresés - Nem strukturált Excel: Áttekinthetetlen, lassú, hibás adatok Adatbázis megoldás: - Gyors keresés bármilyen mező alapján - Többszempontú rendezés - Szűrés kombinált feltételek szerint - Statisztikák, összesítések másodpercek alatt 2.2.2 Kapcsolatok kezelése Az adatok között gyakran bonyolult kapcsolatrendszerek vannak. Példa: Kutatószolgálat Kovács János kutatót nyilván kell tartani (név, cím, email, telefon, intézmény) Kovács János többször is jön kutatni (látogatások dátumai, időpontjai) Minden látogatáson több fondból kérhet Egy fondot több kutató is kérhet Egy fondban több doboz van Minden kérésről dokumentálni kell, ki, mit, mikor kért Hagyományos megoldás (Excel): Név | Email | Dátum | Fond | Doboz Kovács János| k@... | 2024.11.05| XXV-1 | 3 Kovács János| k@... | 2024.11.05| XXV-2 | 5 Kovács János| k@... | 2024.11.12| XXV-1 | 4 Probléma: Ha Kovács János emailje megváltozik, mindhárom sort javítani kell! Adatbázis megoldás: - Kovács János adatai egyszer szerepelnek (KUTATÓK tábla) - Látogatásai külön táblában (LÁTOGATÁSOK) - Kérései külön táblában (KÉRÉSEK) - Email változás → egy helyen javítás 2.2.3 Probléma 3: Adatintegritás Adatintegritás: Az adatok pontosak, konzisztensek és megbízhatóak. Gyakori hibák strukturálatlan adatkezelésben: Elgépelés: “Kovács János” vs “Kovacs János” vs “Kovács Janos” Hiányzó kötelező adat: Fond jelzet nélküli rekord Nem létező hivatkozás: Olyan fondot kérnek, ami nincs nyilvántartva Duplikáció: Ugyanaz az adat többször szerepel Elavult adat: Az egyik helyen frissítve, máshol nem Adatbázis megoldás: - Típusellenőrzés: Csak szám írható be a “Születési év” mezőbe - Kötelező mezők: Nem menthető rekord fondjel nélkül - Referenciális integritás: Csak létező fondra lehet hivatkozni - Egyedi kulcs: Nem lehet két azonos kutatói azonosító - Automatikus frissítés: Kapcsolt adatok automatikusan frissülnek 2.3 Adatbázisok a levéltári munkában 2.3.1 Tipikus felhasználási területek Táblázat 2.1: Adatbázis alkalmazások a levéltárban Terület Leírás Bonyolultság Nyilvántartás Fondok, dobozok, iratok hierarchikus rendszere Közepes Iktatókönyv Iktatott ügyek, iktatószámok, ügyintézők, határidők Közepes Kutatószolgálat Kutatók, látogatások, kért fondok, engedélyek Magas Digitalizálási projekt Dobozok, iratok, szkennelés státusza, munkatársak Közepes Raktárkezelés Épületek, raktárak, polcok, fondok elhelyezése Egyszerű Kiállítás menedzsment Kiállítások, kiállított tárgyak, iratok, kölcsönzések Magas Munkatársi nyilvántartás Munkatársak, jogosultságok, szakterületek Egyszerű 2.3.2 Előnyök a levéltári munkában Gyors keresés: Bármely mező szerint másodpercek alatt Statisztikák: Hány fond, mennyi terjedelem, évenkénti bontás Kapcsolatok: Ki, mikor, mit kért - összetett lekérdezések Jelentések: Automatikus kimutatások, összesítők Többfelhasználós: Több munkatárs dolgozhat egy időben (korlátokkal) Verziókövetés: Ki, mikor módosított mit Biztonsági mentés: Automatikus backup rendszerek 2.4 Az adatbázisok fejlődése 2.4.1 Rövid történeti áttekintés 1960-as évek: Hierarchikus és hálós adatbázisok - IBM IMS (Information Management System) - Merev struktúra, nehéz módosítás 1970-es évek: Relációs modell megjelenése - Edgar F. Codd publikációja (1970) - SQL nyelv kifejlesztése - Rugalmas, matematikai alapokon nyugvó modell 1980-as évek: Relációs adatbázisok elterjedése - Oracle, DB2, Microsoft SQL Server - Személyi számítógépeken is elérhetővé válnak 1990-es évek: Desktop adatbázisok - Microsoft Access (1992) - Nem informatikusok is használhatják - Levéltárak is elkezdik használni 2000-es évek: Web-alapú rendszerek - MySQL, PostgreSQL térnyerése - Online katalógusok, digitális archívumok 2010-es évek: NoSQL és Big Data - MongoDB, Cassandra - Hatalmas adatmennyiségek kezelése - Nem strukturált adatok (képek, videók) 2.5 Ellenőrző kérdések Mit jelent az, hogy az adatok “strukturáltan” vannak tárolva? Milyen problémákat old meg egy adatbázis a hagyományos (pl. Word) megoldásokhoz képest? Mi az adatintegritás, és miért fontos? Mondjon példát egy levéltári felhasználási területre, ahol adatbázis használata indokolt! Miért előnyös az adatbázisokban, hogy az adatok kapcsolatban vannak egymással? 2.6 Következő fejezet A következő fejezetben részletesen megismerjük a különböző adatbázis típusokat: lapos, relációs, hierarchikus, hálós, és NoSQL adatbázisokat. Megnézzük, mikor melyiket érdemes használni, és milyen előnyökkel, hátrányokkal rendelkeznek. "],["adatbázis-típusok-részletesen.html", "3 Adatbázis típusok részletesen 3.1 Lapos (flat file) adatbázisok 3.2 Hierarchikus adatbázisok 3.3 Hálós (network) adatbázisok 3.4 Relációs adatbázisok 3.5 NoSQL adatbázisok - A 21. század kihívásai 3.6 Ellenőrző kérdések", " 3 Adatbázis típusok részletesen A következőkben részletesen megvizsgáljuk az öt legfontosabb adatbázis-típust. 3.1 Lapos (flat file) adatbázisok A lapos adatbázis a legegyszerűbb forma: egyetlen táblázat, amelyben sorok és oszlopok vannak. Minden sor egy rekord, minden oszlop egy mező. Nincs kapcsolat más táblákkal. 3.1.1 Példa: Levéltári fondlista Fond Megnevezés Kezdő_év Záró_év Terjedelem_ifm XIX-A-1 Miniszterelnökség 1944 1949 79 XIX-I-1 Vallás- és Közoktatásügyi Minisztérium 1945 1951 447 XXVIII-M-19 Magyar Nők Demokratikus Szövetsége 1948 1955 1.6 3.1.2 Mikor működik jól? Kis adatmennyiség Nincs kapcsolat az adatok között Egyszerű lista Ideiglenes adatgyűjtés 3.1.3 A redundancia problémája Ha kutatók látogatásait is nyilvántartjuk: Kutató_név Email Telefon Dátum Fond Kovács János kovacs@elte.hu 06-1-123 2024-11-05 XXV-1 Kovács János kovacs@elte.hu 06-1-123 2024-11-05 XXV-2 Kovács János kovacs@elte.hu 06-1-123 2024-11-12 XXV-1 Kovács János adatai háromszor ismétlődnek! Ez redundancia. Problémák: - Helypazarlás (3x tárolás) - Frissítés nehéz (3 helyen kell módosítani) - Inkonzisztencia veszély (elfelejtünk egy helyet) 3.1.4 Mikor NE használjuk? Kapcsolatok vannak az adatok között Több mint 1000 rekord Adatintegritás kritikus Gyakran változnak az adatok 3.2 Hierarchikus adatbázisok 3.2.1 Történeti háttér Az 1960-as években születtek az első hierarchikus adatbázisok, amelyeket a NASA Apollo programjában használtak. A legismertebb: IBM IMS (1968). 3.2.2 A fa struktúra A hierarchikus adatbázis egy fa struktúra: - Van egy gyökér (root) - Minden elemnek egy szülője van (kivéve a gyökér) - Egy szülőnek több gyereke lehet 3.2.3 Levéltári példa: Fond-hierarchia LEVÉLTÁR (gyökér) │ ├─── MNL Országos Levéltára │ │ │ ├─── XIX fondfőcsoport │ │ │ │ │ ├─── XIX-A-83 fond │ │ └─── XIX-A-84 fond │ │ │ └─── XX fondfőcsoport │ └─── Budapest Főváros Levéltára │ └─── IV. fondfőcsoport 3.2.4 Előnyök Természetes modellezés: Sok dolog eleve hierarchikus (szervezet, földrajz, levéltári rendszer) Gyors navigáció: Szülőtől gyerekhez, gyerektől szülőhöz Adatintegritás: Gyerek mindig tartozik valahova Hatékony tárolás: Nincs redundancia 1:N kapcsolatoknál 3.2.5 Korlátok Merev struktúra: Új szint beszúrása nagyon nehéz Sok-sok kapcsolatok: Csak duplikálással megoldható Procedurális lekérdezések: Pontosan le kell írni a navigációt Nincs szabvány: Minden rendszer más 3.2.6 Miért vesztették el népszerűségüket? Az 1980-as évekre a relációs modell (SQL) kiszorította őket, mert: - Rugalmasabb - Egyszerűbb lekérdezések (SQL) - Szabványos nyelv Ma XML adatbázisok formájában élnek tovább: - TEI XML kódolt történeti szövegek - EAD (Encoded Archival Description) levéltári leírások - Konfigurációs fájlok — 3.3 Hálós (network) adatbázisok 3.3.1 A sok-sok kapcsolat problémája A hierarchikus modell nem tudja kezelni a sok-sok kapcsolatokat. Példa: - Egy színész több előadásban játszik - Egy előadásban több színész játszik 3.3.2 CODASYL hálós modell (1969) A CODASYL (Conference on Data Systems Languages) bizottság 1969-ben fejlesztette ki a hálós modellt, amely lehetővé teszi, hogy egy elemnek több szülője is legyen. 3.3.3 Működés Rekord típusok: Entitások (pl. KUTATÓK, TÉMÁK, FONDOK) Set típusok: Kapcsolatok (pl. KUTATÓ-TÉMÁK set) Owner-member: Tulajdonos és tagok 3.3.4 Példa: Kutatási hálózat KUTATÓK ←──[KUTATÓ-TÉMÁK set]──→ TÉMÁK ↓ ↓ [KUTATÓ-FONDOK set] [TÉMA-FONDOK set] ↓ ↓ FONDOK ←─────────────────────────→ FONDOK 3.3.5 Miért vesztették el népszerűségüket? Túl bonyolult: Nehéz megtervezni és megérteni Procedurális programozás: Sok kód kell egyszerű lekérdezéshez is Nincs szabvány: Minden gyártó más nyelvet használt SQL egyszerűbb: A relációs modell ugyanazt tudta, de egyszerűbben 3.3.6 Modern megfelelő: Gráf adatbázisok Ma a gráf adatbázisok (Neo4j, Amazon Neptune) hasonló elvet követnek: - Csomópontok (nodes) - entitások - Élek (edges) - kapcsolatok - Cypher nyelv - deklaratív lekérdezés Levéltári példa: Prozopográfia - 19. századi értelmiségiek kapcsolati hálója 3.4 Relációs adatbázisok 1970-ben Edgar F. Codd, IBM kutató publikálta a relációs modellt. 3.4.1 Mi az újdonság? Táblázatok és kapcsolatok: - Adatok táblákban (relációkban) - Táblák matematikailag definiált kapcsolatokkal - SQL - deklaratív lekérdező nyelv - ACID tulajdonságok (megbízhatóság) 3.4.2 Kulcsok Elsődleges kulcs (Primary Key - PK): - Egyedileg azonosít minden rekordot - Nem lehet NULL - Nem változik Idegen kulcs (Foreign Key - FK): - Másik tábla PK-jára hivatkozik - Létrehoz kapcsolatot 3.4.3 Példa: Kutatószolgálat KUTATÓK tábla: Kutató_ID (PK) Név Email 1 Kovács János kovacs@elte.hu 2 Nagy Anna nagy@ppk.hu LÁTOGATÁSOK tábla: Látogatás_ID (PK) Kutató_ID (FK) Dátum 101 1 2024-11-05 102 1 2024-11-12 103 2 2024-11-06 A Kutató_ID a LÁTOGATÁSOK táblában idegen kulcs - hivatkozik a KUTATÓK tábla elsődleges kulcsára. 3.4.4 Kapcsolat típusok 1:N (Egy a többhöz): - Egy kutató → Több látogatás - Egy fond → Több doboz N:M (Sok a sokhoz): - Egy látogatás → Több fond - Egy fond → Több látogatás - Megoldás: Kapcsoló tábla (KÉRÉSEK) 1:1 (Egy az egyhez): - Ritka - Egy munkatárs → Egy bejelentkezési fiók 3.4.5 Normalizálás - Az adatredundancia elleni harc A normalizálás az a folyamat, amellyel az adatbázis struktúráját úgy alakítjuk, hogy minimalizáljuk a redundanciát (ismétlődést) és maximalizáljuk az adatintegritást. A normálformák olyan szabályrendszerek, amelyek fokozatosan szigorúbbak. Minden magasabb normálforma tartalmazza az alacsonyabb szintűek követelményeit is. A gyakorlatban általában a 3. normálforma (3NF) elég - a magasabb szintek ritkán szükségesek. 3.4.5.1 1. Normálforma (1NF) - Atomicitás Szabály: Minden mező atomi (tovább nem bontható) értéket tartalmaz, és egyetlen értéket tartalmaz. Mit TILOS: - Lista egy cellában - Több érték vesszővel elválasztva - Összetett adatok Rossz példa (NEM 1NF): Kutató_ID Név Kutatási_témák 1 Kovács János Kádár-kor, Színház, 1956-os forradalom 2 Nagy Anna Levéltártan, Digitalizálás Probléma: A “Kutatási_témák” mező három értéket tartalmaz egy cellában! Ez nem atomi. Miért rossz? - Nem tudsz keresni: “Kik kutatják a színházat?” → Nehéz szűrni - Nem tudsz rendezni témák szerint - Nem tudsz statisztikát készíteni: “Hány kutató kutatja a Kádár-kort?” Jó példa (1NF-ben): Megoldás 1: Több sor Kutató_ID Név Kutatási_téma 1 Kovács János Kádár-kor 1 Kovács János Színház 1 Kovács János 1956-os forradalom 2 Nagy Anna Levéltártan 2 Nagy Anna Digitalizálás Most minden mező egyetlen értéket tartalmaz! Megoldás 2: Külön tábla (jobb!) KUTATÓK tábla: Kutató_ID Név 1 Kovács János 2 Nagy Anna KUTATÁSI_TÉMÁK tábla: Téma_ID Téma_neve 1 Kádár-kor 2 Színház 3 1956-os forradalom 4 Levéltártan 5 Digitalizálás KUTATÓ_TÉMÁK kapcsoló tábla: Kutató_ID Téma_ID 1 1 1 2 1 3 2 4 2 5 Ez tiszta 1NF és könnyen kezelhető! 3.4.5.2 2. Normálforma (2NF) - Teljes függés Szabály: Teljesíti az 1NF-et, ÉS minden nem-kulcs mező teljesen függ az elsődleges kulcstól (nem csak egy részétől). Ez akkor releváns, ha az elsődleges kulcs összetett (több mezőből áll). Rossz példa (NEM 2NF): Képzeljük el, hogy 3.4.6 Referenciális integritás Garantálja, hogy idegen kulcsok mindig létező elsődleges kulcsra hivatkoznak. CASCADE DELETE: Ha törlöd a szülőt, törlődnek a gyerekek is CASCADE UPDATE: Ha megváltozik a PK, frissülnek az FK-k 3.4.7 Miért nyertek? Egyszerű: Táblák könnyebben érthetők Rugalmas: Új táblák, kapcsolatok könnyen hozzáadhatók SQL szabvány: Egységes nyelv Matematikai alapok: Relációs algebra ACID: Megbízhatóság 3.4.8 Népszerű rendszerek Rendszer Típus Használat Microsoft Access Desktop Kis levéltárak MySQL Szerver Webalkalmazások PostgreSQL Szerver Komplex rendszerek SQL Server Szerver Vállalati Oracle Szerver Nagy vállalatok SQLite Beágyazott Mobil appok 3.5 NoSQL adatbázisok - A 21. század kihívásai 3.5.1 A Big Data kihívás: Miért kellett valami új? (2000-es évek) Az ezredforduló után az internet robbanásszerű növekedésével olyan új típusú problémák jelentek meg, amelyekre a hagyományos relációs adatbázisok nem adtak jó választ. A Google problémája: - Több milliárd weboldal indexelése naponta - Keresési lekérdezések másodpercenként: milliók - Adatmennyiség: több petabyte (1 petabyte = 1.000.000 GB!) - Relációs adatbázis erre: összeomlik A Facebook problémája: - Több mint 2 milliárd felhasználó - Minden felhasználónak más-más adatstruktúrája (ki kitölt mit a profilban) - Posztok, fotók, kommentek, reakciók: trilliónyi rekord - Kapcsolatok: ki kivel barátkozik, ki mit lájkol - hatalmas hálózat - Relációs adatbázis erre: túl lassú, nem skálázható Az Amazon problémája: - Több százmillió termék - Minden terméknek különböző tulajdonságai (könyv: ISBN, szerző; TV: képátló, felbontás; ruha: méret, szín) - Vásárlások, kosár, ajánlások: folyamatos írás-olvasás - Black Friday: másodpercenként százezernyi vásárlás - Relációs adatbázis erre: merev séma, lassú A közös problémák: Extrém nagy adatmennyiség (Volume) Petabyte vagy akár exabyte (1.000.000.000 GB) méretű adatok Egyetlen szerveren lehetetlen tárolni Több ezer szerverre kell elosztani Nagyon gyors írás (Velocity) Másodpercenként százezernyi vagy milliónyi új rekord (tweet, log, szenzor adat) A relációs adatbázisok ACID tranzakciói túl lassúak Kell a “gyors és piszkos” írás - ellenőrzés később Változó struktúra (Variety) Nem minden felhasználó tölti ki ugyanazokat a mezőket Új mezők jelennek meg naponta (pl. új termékattribútumok) Relációs fix séma: minden táblamódosításhoz ALTER TABLE kell → lassú Kell a rugalmas séma: minden dokumentum lehet más Horizontális skálázhatóság Relációs adatbázisok vertikálisan skáláznak: veszünk egy nagyobb szervert (több RAM, gyorsabb CPU) De: van felső határ (a legnagyobb szerver is véges), és nagyon drága Kell a horizontális skálázás: több olcsó szervert adunk hozzá, és eloszlatjuk az adatokat “Divide and conquer” - oszd meg és uralkodj 3.5.2 Mi az a NoSQL? A NoSQL kifejezés Not Only SQL-t jelent - nem azt, hogy “nincs SQL”, hanem hogy “nem csak SQL, hanem más megközelítések is léteznek”. Fontos: A NoSQL nem egyetlen technológia vagy termék, hanem egy gyűjtőfogalom különböző, nem-relációs adatbázis-modellekre. Közös bennük: - Elutasítják a relációs modell merevségét - Rugalmasságot preferálnak konzisztencia helyett - Horizontális skálázásra optimalizáltak Közös jellemzők: Nincs fix séma (Schema-less vagy Schema-free) Minden rekord/dokumentum különböző mezőkkel rendelkezhet Új mezők hozzáadása: egyszerűen beírod, nincs ALTER TABLE Rugalmas, gyors fejlesztés Horizontális skálázás (Scale-out) Könnyű több szervert hozzáadni Adatok automatikusan elosztódnak (sharding, partitioning) Több olcsó szerver &gt; egy drága szerver Eventual consistency (Végül konzisztens) Nem garantált az azonnali konzisztencia Kis késleltetéssel (milliszekundumok/másodpercek) minden szerver frissül “Végül” minden adat egyezni fog Nagy teljesítmény nagy terhelésnél Optimalizáltak gyors írásra/olvasásra Nincs bonyolult JOIN, nincs komplex tranzakció → gyorsabb Specializáltság Minden NoSQL típus más-más problémára optimalizált Nincs univerzális megoldás (mint a relációs) 3.5.3 NoSQL típusok részletesen A NoSQL adatbázisokat négy fő kategóriába soroljuk: 3.5.3.1 1. Dokumentum-orientált adatbázisok (pl. MongoDB) Alapelv: Az adatok JSON vagy XML dokumentumokban tárolva, ahol minden dokumentum egy önálló egység. Előnyök: Rugalmas séma: Minden kutató dokumentuma különböző lehet Van akinek van “publikációk_száma”, van akinek nincs Van aki több nyelvet beszél, van aki egyet Új mezőt bármikor hozzáadhatsz Beágyazott struktúrák: Az intézmény és kutatási_területek beágyazva Nincs szükség JOIN-ra Egy lekérdezés mindent megad Gyors olvasás: Minden adat egy dokumentumban Nem kell 3-4 táblát összekapcsolni Egy keresés = teljes adathalmaz Természetes JSON: Webalkalmazásokkal könnyen integrálható Frontend JavaScript közvetlenül használja API válaszok JSON formátumban Hátrányok: Nincs JOIN: Kapcsolatok nehezen kezelhetők Ha a kutató több fondot kutat, azokat ismételni kell, vagy külön táblában Redundancia: Ha ugyanaz az intézmény adat sok kutatónál szerepel “ELTE BTK” címe duplikálva van Frissítés: minden kutatónál külön kell módosítani Nincs séma-validáció: Bárki bármit beírhat Egyik dokumentumban születési_év: 1985 (szám) Másikban születési_év: \"ezerkilencszáznyolcvanöt\" (szöveg) Nincs automatikus ellenőrzés Mikor használjuk? Content Management rendszerek (CMS) - Blog bejegyzések: különböző mezők (cím, szöveg, képek, videók, címkék) - Termékleírások: minden termék különböző attribútumokkal Katalógusok - Könyv: ISBN, szerző, kiadó - Film: rendező, szereplők, időtartam - Ruha: méret, szín, anyag - Mindegyik más mezők → MongoDB rugalmasan kezeli Felhasználói profilok - Közösségi média: mindenki mást tölt ki a profiljában - Nincs fix séma Levéltári példa: Digitális born-digital iratok metaadatai MongoDB-ben: ## Összefoglalás | Típus | Mikor ideális? | Fő előny | Fő hátrány | |-------|----------------|----------|------------| | Lapos | Kis lista | Egyszerű | Redundancia | | Hierarchikus | Fa struktúra | Gyors navigáció | Merev | | Hálós | *(elavult)* | Sok-sok | Bonyolult | | Relációs | Legtöbb eset | SQL, integritás | Vertikális skálázás | | NoSQL | Big Data | Skálázható | Nincs ACID | Levéltári munka: 90% esetben relációs (Access, MySQL) 3.6 Ellenőrző kérdések Mi a redundancia? Miért probléma? Milyen előnyei vannak a hierarchikus modellnek? Miért vesztették el népszerűségüket a hálós adatbázisok? Mi volt Edgar F. Codd forradalmi ötlete? Mi a különbség az elsődleges és idegen kulcs között? Milyen kapcsolat típusokat vannak? Mit jelent a normalizálás? Mi az a NoSQL? Mikor használjuk? Milyen NoSQL típusokat vannak Melyik adatbázis-típust választana egy levéltári fondnyilvántartáshoz? Miért? "],["excel-vs-access---döntés-a-gyakorlatban.html", "4 Excel vs Access - Döntés a gyakorlatban 4.1 Mi az Excel és mi az Access? 4.2 Részletes összehasonlítás 4.3 Átmenet Excelből Accessbe - Lépésről lépésre 4.4 Ellenőrző kérdések", " 4 Excel vs Access - Döntés a gyakorlatban A gyakorlatban a legtöbb levéltáros vagy történész két Microsoft program között választ: Excel vagy Access. Ebben a fejezetben megvizsgáljuk, hogy mikor melyiket érdemes használni, és hogyan lehet áttérni Excelből Accessbe. 4.1 Mi az Excel és mi az Access? Mielőtt eldöntjük, melyiket használjuk, meg kell értenünk, hogy mire tervezték őket. Az Excel és az Access ugyan mindkettő a Microsoft Office része, de alapvetően különböző problémákat oldanak meg. 4.1.1 Excel: A táblázatkezelő (Spreadsheet) Az Excel 1985-ben jelent meg. Az alapelv egyszerű: egy hatalmas táblázat, ahol minden cella tartalmazhat számot, szöveget vagy képletet. 4.1.1.1 Mire tervezték az Excelt? 1. Számolásra és pénzügyi elemzésre Az első táblázatkezelők (1970-es évek) számviteli feladatokhoz készültek: költségvetés tervezése, bevételek-kiadások követése, “Mi lenne, ha…” elemzések. Példa: Költségvetés A B C D 1 Kategória Terv_Ft Valós_Ft Eltérés_Ft 2 Személyi 5000000 4850000 =C2-B2 3 Dologi 2000000 2150000 =C3-B3 4 Beruházás 3000000 2900000 =C4-B4 5 ─────────────────────────────────────────────── 6 Összesen =SUM(B2:B4) =SUM(C2:C4) =SUM(D2:D4) Ha megváltoztatjuk a B2 cellát → azonnal frissülnek az összes kapcsolódó cella. Ez az Excel erőssége: dinamikus, interaktív számolás. 2. Adatelemzésre és vizualizációra Pivot táblák (1994): Húzd-és-dobd összesítések Grafikonok: 50+ típus - szépen formázható Conditional formatting: Cellák automatikus színezése érték alapján 3. Gyors prototípus készítésére Az Excel azonnal elindítható, nincs szükség adatbázis-tervezésre - megnyitjuk, beírjuk az adatokat. Jellemzői: Képletek és függvények: 400+ beépített függvény (SUM, AVERAGE, VLOOKUP, IF, DATE…) Grafikonok: Szép vizualizációk, interaktív elemek Pivot táblák: Gyors összesítések húzd-és-dobd módszerrel Makrók (VBA): Programozható automatizálás Filozófia: Az Excel egy rugalmas, vizuális számológép - gyors, egyszerű, intuitív. Nem adatbázis, hanem munkafelület számoláshoz és elemzéshez. 4.1.2 Access: Az adatbázis-kezelő (RDBMS) A Microsoft Access 1992-ben jelent meg - egy relációs adatbázis-kezelő rendszer (RDBMS) asztali környezetbe tervezve. A cél az volt, hogy kis- és középvállalatok is elérhető áron tudjanak professzionális adatbázisokat építeni. 4.1.2.1 Mire tervezték az Accesst? 1. Kapcsolatok kezelésére Az Access relációs modellt valósít meg - Edgar F. Codd 1970-es elméletére épül: táblák, kapcsolatok, referenciális integritás. Példa: Kutatószolgálat KUTATÓK tábla: Kutató_ID (PK) Név Email Intézmény 1 Kovács János kovacs@elte.hu ELTE BTK 2 Nagy Anna nagy@ppk.hu PPKE BTK LÁTOGATÁSOK tábla: Látogatás_ID (PK) Kutató_ID (FK) Dátum Megjegyzés 101 1 2024-11-05 Kádár-kor kutatás 102 1 2024-11-12 Színháztörténet 103 2 2024-11-06 Levéltártan IRATOK tábla: Fond_ID (PK) Jelzet Megnevezés 5 XXV-1 Tanácsi ülések 7 XXV-2 Polgármesteri KÉRÉSEK kapcsoló tábla (N:M): Kérés_ID (PK) Látogatás_ID (FK) Fond_ID (FK) 1 101 5 2 101 7 3 102 5 Kapcsolatok: - KUTATÓK ↔︎ LÁTOGATÁSOK: 1:N (egy kutató → több látogatás) - LÁTOGATÁSOK ↔︎ IRATOK: N:M (kapcsoló táblával) Ez Excelben lehetetlen tisztán megoldani! 2. SQL lekérdezésekre Az Access SQL-t használ - összetett lekérdezések egyszerűen: -- Kik látogattak novemberben és milyen fondokat kértek? SELECT Kutatók.Név, Látogatások.Dátum, Iratok.Jelzet FROM ((Kutatók INNER JOIN Látogatások ON Kutatók.Kutató_ID = Látogatások.Kutató_ID) INNER JOIN Kérések ON Látogatások.Látogatás_ID = Kérések.Látogatás_ID) INNER JOIN Iratok ON Kérések.Fond_ID = Iratok.Fond_ID WHERE Látogatások.Dátum BETWEEN #2024-11-01# AND #2024-11-30#; 3. Űrlapokra és jelentésekre Az Access felhasználói felületet is biztosít: Űrlapok: Adatbevitel user-friendly módon, validációval, dropdown listákkal Jelentések: Nyomtatható dokumentumok, csoportosítással, összesítésekkel 4. Referenciális integritásra Az Access garantálja, hogy idegen kulcs mindig létező elsődleges kulcsra mutat - nem lehet törölni szülőt, ha van gyerek rekord. Filozófia: Az Access egy relációs adatbázis-kezelő - strukturált, szabályozott, integritás-központú. Nem számolásra, hanem adatok biztonságos tárolására és összekapcsolására tervezték. 4.2 Részletes összehasonlítás 4.2.1 Adatstruktúra Excel: - Munkafüzet → Munkalapok (függetlenek egymástól) - Nincs automatikus kapcsolat - VLOOKUP-pal “kapcsoljuk össze” őket Access: - Adatbázis → Táblák (kapcsolódnak egymáshoz) - Grafikus relationship designer - Natív JOIN-ok 4.2.2 Adatmennyiség és teljesítmény Szempont Excel Access Max sorok 1.048.576 ~2 GB fájl Gyakorlatban ~10.000 sor Millió+ 1.000 sornál Gyors Gyors 10.000 sornál Lassul Gyors 100.000 sornál Nagyon lassú Gyors Valós példa: 5.000 fond Excelben = 20 mp megnyitás, 15 mp szűrés. Ugyanez Accessben = 2 mp megnyitás, azonnali szűrés. 4.2.3 Kapcsolatok kezelése: VLOOKUP pokla vs JOIN egyszerűsége Excel - VLOOKUP problémák: Két munkalap: KUTATÓK (Kutató_ID, Név) és LÁTOGATÁSOK (Látogatás_ID, Kutató_ID, Dátum). A LÁTOGATÁSOK-ban minden sorban kell egy VLOOKUP: =VLOOKUP(B2, Kutatók!A:B, 2, FALSE) Problémák: - Törékeny: Oszlop sorrend változik → elromlik - Lassú: Minden cellában újra számol - Korlátozott: Csak jobbra keres - Nincs integritás: Lehet nem létező ID - Karbantartás: Új oszlopnál frissíteni kell a képletet - Hibakezelés: #N/A hibák, ha nincs találat Valós történet: Beszúrtunk egy új oszlopot a KUTATÓK táblába → 300 sor VLOOKUP elromlott, mert megváltozott az oszlopsorrend! Access - JOIN egyszerűsége: SELECT Látogatások.Dátum, Kutatók.Név FROM Kutatók INNER JOIN Látogatások ON Kutatók.Kutató_ID = Látogatások.Kutató_ID; Vagy grafikusan a Query Designerben! Nincs törékeny képlet, nincs karbantartás. 4.2.4 Adatintegritás Funkció Excel Access Mezőtípus Nincs ellenőrzés Szigorú (Text, Number, Date…) Kötelező mezők Nincs Required = Yes Egyedi értékek Nincs automatikus Primary Key Ref. integritás Nincs Enforce Referential Integrity Validáció Data Validation (korlátozott) Validation Rule + Input Mask Példa: Születési év validáció Excelben: 1985 ✓ (OK) nyolcvan ✓ (elfogadja! - ROSSZ) 3025 ✓ (elfogadja! - jövőbeli év) (üres) ✓ (elfogadja!) Accessben: - Data Type: Number - Required: Yes - Validation Rule: Between 1900 And Year(Date()) - Input Message: “Adjon meg egy születési évet 1900-2024 között” - Ha hibás → NEM ENGEDI ELMENTENI 4.2.5 Felhasználói felület Excel: Cellák - gyors, de veszélyes (könnyen el lehet rontani, bárki bármit beírhat) Access: Űrlapok - user-friendly, biztonságos ┌─────────────────────────────┐ │ Új kutató felvétele │ ├─────────────────────────────┤ │ Név: [____________] │ │ Email: [___________] │ │ Intézmény: [▼ ELTE BTK] │ │ │ │ [Mentés] [Mégse] [Törlés] │ └─────────────────────────────┘ 4.2.6 Több felhasználó egyidejű munkája Excel: - Egyszerre csak egy ember tud írni - Megosztott munkafüzet létezik, de korlátozott és gyakori ütközés - Verziókonfliktusok Access: - Split Database: Több ember dolgozhat egyidejűleg - Record locking: Ki kinek a sorát szerkeszti - Nincs verziókonfliktus 4.2.7 Amit az Excel jobban tud Számítások és képletek: SUM, AVERAGE, IF, komplex pénzügyi függvények Grafikonok: Gyönyörű vizualizációk, sok típus Pivot táblák: Interaktív, húzd-és-dobd elemzés Gyors prototípus: Azonnal kezdhetünk Ad-hoc elemzés: Szabadon kísérletezhetünk Következtetés: Excel és Access kiegészítők, nem konkurensek! Gyakori workflow: 1. Excel → Adatgyűjtés, gyors bevitel 2. Access → Strukturálás, kapcsolatok, hosszú távú tárolás 3. Excel → Exportálás, statisztikák, grafikonok elemzéshez 4.3 Átmenet Excelből Accessbe - Lépésről lépésre Ha már van egy Excel táblázatunk, de rájöttünk, hogy Access jobb lenne, át kell vinniünk az adatokat. Ez NEM egyszerű másolás-beillesztés - előkészítés és tervezés szükséges! 4.3.1 1. lépés: Tisztítsuk meg az Excel adatokat Az Excel rugalmas - bármit megenged. Az Access szigorú - csak tiszta, strukturált adatokat fogad el. 4.3.1.1 1.1 Távolítsuk el az üres sorokat Probléma: Üres sorok az adatok között - Access nem tudja, hol van vége. Megoldás: 1. Jelöljük ki az A oszlopot 2. Home → Find &amp; Select → Go To Special… 3. Válasszuk: Blanks 4. Jobb klikk → Delete → Delete Sheet Rows 4.3.1.2 1.2 Első sor = Fejléc (és CSAK az!) Probléma: Cím, magyarázat a táblázat felett. Megoldás: Töröljük az 1. sor előtti minden sort. Maradjon CSAK a fejléc az 1. sorban. Jó fejléc: - Rövid, értelmes nevek - Nincs szóköz (használjanak _ vagy CamelCase-t) - Nincs spec. karakter 4.3.1.3 1.3 Nincs összevont cella Megoldás: 1. Jelöljük ki az egész táblát (Ctrl+A) 2. Home → Merge &amp; Center → Unmerge Cells 4.3.1.4 1.4 Nincs képlet (csak értékek) Megoldás: 1. Jelöljük ki a táblát (Ctrl+A) 2. Ctrl+C (másolás) 3. Jobb klikk → Paste Special (Ctrl+Alt+V) 4. Válasszuk: Values 5. OK 4.3.1.5 1.5 Ellenőrző checklist ☐ Nincs üres sor ☐ Első sor = fejléc ☐ Nincs összevont cella ☐ Nincs képlet ☐ Nincs cím/dátum felette ☐ Minden oszlop egy típus ☐ Konzisztens adatok 4.3.2 2. lépés: Tervezzük meg az Access struktúrát NE rohanjanak azonnal importálni! Először gondoljuk végig a struktúrát. 4.3.2.1 2.1 Milyen táblák kellenek? Kérdések: 1. Milyen entitások vannak? 2. Minden entitásnak külön tábla! Példa: Kutatószolgálat Excel tábla (rossz): Kutató_név | Email | Dátum | Fond | Téma Kovács János | kovacs@elte.hu | 2024-11-05 | XXV-1 | Kádár-kor Kovács János | kovacs@elte.hu | 2024-11-05 | XXV-2 | Kádár-kor ← redundancia! Entitások: 1. Kutatók 2. Iratok 3. Látogatások Access táblák: - KUTATÓK (Kutató_ID, Név, Email, Téma) - Iratok (Fond_ID, Jelzet, Megnevezés) - LÁTOGATÁSOK (Látogatás_ID, Kutató_ID, Dátum) - KÉRÉSEK (Kérés_ID, Látogatás_ID, Fond_ID) - kapcsoló tábla N:M-hez 4.3.2.2 2.2 Milyen kapcsolatok vannak? 1:N: Egy kutató → több látogatás N:M: Egy látogatás → több fond, egy fond → több látogatás (kapcsoló tábla kell!) 4.3.2.3 2.3 Rajzoljuj le a struktúrát! KUTATÓK ──1:N── LÁTOGATÁSOK ──N:M── IRATOK │ KÉRÉSEK (kapcsoló tábla) 4.3.3 3. lépés: Importáljuk Accessbe 4.3.3.1 3.1 Access megnyitása Nyissuk meg Access-t Blank Database Fájlnév: Kutatoszolgalat.accdb Create 4.3.3.2 3.2 Excel fájl importálása External Data fül New Data Source → From File → Excel Browse… → Válasszuk ki az Excel fájlt OK Import Wizard: Show Worksheets → Jelöljük be a munkalapot → Next ☑ “First Row Contains Column Headings” → Next Ellenőrizzük az adattípusokat (Text/Number/Date) → Next “Let Access add primary key” → Next Tábla neve (pl. FONDOK) → Finish 4.3.3.3 3.3 Több tábla importálása Importáljuk egyesével: - Kutatók.xlsx → KUTATÓK tábla - Iratok.xlsx → IRATOK tábla - Látogatások.xlsx → LÁTOGATÁSOK tábla 4.3.4 4. lépés: Definiáljuk a kapcsolatokat 4.3.4.1 4.1 Relationships ablak Database Tools → Relationships Jobb klikk → Show Table… Adjunk hozzá minden táblát → Close 4.3.4.2 4.2 Kapcsolat létrehozása KUTATÓK ↔︎ LÁTOGATÁSOK (1:N): Húzzuk Kutató_ID-t KUTATÓK-ból → LÁTOGATÁSOK-ba ☑ Enforce Referential Integrity Cascade Update (NE) Cascade Delete (NE - veszélyes!) Create Mit jelent az Enforce Referential Integrity? Ez garantálja, hogy: - Nem törölhetünk kutatót, akinek van látogatása - Nem írhatunk be nem létező Kutató_ID-t - Adatkonzisztencia garantált ☐ Cascade Update Related Fields: - Ha megváltoztatjuk a szülő elsődleges kulcsát → automatikusan frissül az összes gyerek idegen kulcs - Példa: Kutató_ID = 1 → 100 megváltozik → Access automatikusan átírja az összes Látogatás.Kutató_ID = 1-et 100-ra - Miért NE? Az elsődleges kulcsot sosem kellene megváltoztatni! Ha mégis szükséges, akkor tudatosan, manuálisan tegyük - így látjuk a következményeket. ☐ Cascade Delete Related Records: - Ha törlünk egy szülő rekordot → automatikusan törlődik az összes hozzá tartozó gyerek rekord is - Példa: Törlik Kovács János kutatót → Access automatikusan törli az összes látogatását, kérését, megjegyzését - Miért NE? Adatvesztés veszély! Egy véletlen törlés sok értékes adatot törölhet. Levéltári nyilvántartásban ez elfogadhatatlan. Ajánlott megoldás: - Soft delete: Ne töröljünk, hanem jelöljük inaktívnak - Adjunk hozzá egy “Aktív” mezőt (Igen/Nem) - Törlés helyett: Aktív = Nem - Így megmarad minden adat, de nem jelenik meg a szokásos lekérdezésekben 4.3.4.3 4.3 További kapcsolatok Ugyanígy: - LÁTOGATÁSOK ↔︎ KÉRÉSEK - IRATOK ↔︎ KÉRÉSEK 4.3.4.4 4.4 Ellenőrzés Teszt: Próbáljunk meg törölni egy kutatót, akinek van látogatása. Eredmény: Access: &quot;The record cannot be deleted because table &#39;LÁTOGATÁSOK&#39; includes related records.&quot; ✓ Működik! A referenciális integritás működik! 4.3.5 Gyakori buktatók az átmenetnél Dátumok elromlanak: Állítsuk Date/Time típusra, ellenőrizzük az import után Nullák eltűnnek: “007” → Text típus kell Encoding: UTF-8 használata magyar ékezetek miatt Redundancia: Normalizálják, mielőtt importálnak! 4.4 Ellenőrző kérdések Mi a fő különbség az Excel és Access filozófiájában? Milyen konkrét problémák vannak a VLOOKUP használatával? Mit jelent az adatintegritás? Hogyan biztosítja Access? Mikor érdemes Excelt használni Access helyett? Mit jelent a referenciális integritás? Miért fontos? Milyen lépések szükségesek az Excel → Access átmenethez? Miért veszélyes a Cascade Delete opció? Hány rekordnál kezd lassulni az Excel a gyakorlatban? Hogyan működik a kapcsoló tábla N:M kapcsolatnál? Mit kell ellenőrizni az Excel importálása előtt? "],["excel-alapok---gyakorlati-bevezetés.html", "5 Excel alapok - Gyakorlati bevezetés 5.1 Az Excel mint adatbázis-előkészítő 5.2 Alapvető navigáció 5.3 Táblázat felépítése - 6 aranyszabály 5.4 Formázás 5.5 Szűrés és rendezés 5.6 Adat validáció 5.7 Gyakori hibák 5.8 Checklist - Jó Excel adattábla 5.9 Ellenőrző kérdések", " 5 Excel alapok - Gyakorlati bevezetés Az Excelt nem “táblázatkezelőként”, hanem strukturált adattárolóként fogjuk használni - adatbázis-szerűen. 5.1 Az Excel mint adatbázis-előkészítő ROSSZ (hagyományos): A B C 1 Levéltár adatok 2024. november 2 3 Fondok száma: 25 JÓ (adatbázis-szerű): A B C D 1 Fondjel Megnevezés Kezdő_év Záró_év 2 XXV-1 Tanácsi ülések 1950 1990 3 XXV-2 Polgármesteri 1960 1989 5.2 Alapvető navigáció 5.2.1 Billentyűk: Billentyű Művelet ↑ ↓ ← → Szomszédos cella Tab Jobbra (→) Enter Lefelé (↓) Ctrl + ↑ ↓ ← → Ugrás adatblokk szélére Ctrl + Home A1-re Ctrl + End Utolsó használt cella Pro tipp: Ctrl + nyilak = gyors navigáció 1000+ soros adatban! 5.3 Táblázat felépítése - 6 aranyszabály 5.3.1 Első sor = Fejléc A1: Fondjel B1: Megnevezés C1: Kezdő_év Tippek: - Rövid, értelmes - Nincs szóköz (használj _ vagy CamelCase) - Egyedi nevek 5.3.2 Minden sor = Egy rekord 2 XXV-1 Tanácsi ülések 1950 1990 3 XXV-2 Polgármesteri 1960 1989 5.3.3 Nincs üres sor Rossz: 2 XXV-1 ... 3 XXV-2 ... 4 ← ÜRes! 5 XXV-3 ... Jó: 2 XXV-1 ... 3 XXV-2 ... 4 XXV-3 ... 5.3.4 Nincs összevont cella Merge Cells - NE használjuk! 5.3.5 Egy oszlop = Egy típus Rossz: Terjedelem 5 ifm 3 doboz 8 Jó: Terjedelem_érték Egység 5 ifm 3 ifm 8 ifm 5.3.6 Atomi értékek Rossz: Témák Kádár-kor, Színház, 1956 Jó: Téma_1 Téma_2 Kádár-kor Színház 5.4 Formázás 5.4.1 Fejléc kiemelése Jelöld ki az 1. sort Home → Bold (Ctrl+B) Fill Color (világoskék/szürke) Center (középre) 5.4.2 Table formázás Kattints bárhova az adattáblán Home → Format as Table Válassz stílust ☑ “My table has headers” OK Eredmény: - Alternatív sor színek - Szűrő nyilak (▼) automatikusan - Dinamikus bővülés 5.4.3 Freeze Panes Fejléc rögzítése (mindig látszik): Kattints A2-re View → Freeze Panes → Freeze Panes Kész! 5.5 Szűrés és rendezés 5.5.1 Szűrés Klikk a nyílra (▼) a fejlécben: Egyszerű szűrés: - Pipálgatás (mely értékek látszódjanak) Number Filters: - Greater Than… (Nagyobb, mint) - Between… (Tartományban) Példa: Mutasd az 1950 után kezdődő fondokat 1. Kezdő_év nyíl → Number Filters → Greater Than… 2. Írd be: 1950 3. OK 5.5.2 Rendezés Klikk a nyílra → Sort Smallest to Largest (növekvő) Több szempont: 1. Data → Sort 2. Sort by: Kezdő_év 3. Add Level 4. Then by: Megnevezés 5. OK 5.6 Adat validáció Hibák megelőzése - korlátozzuk, mi írható be. 5.6.1 Születési év (1900-2024) Jelöld ki az oszlopot (pl. D2:D100) Data → Data Validation Settings: Allow: Whole number Data: between Minimum: 1900 Maximum: 2024 Error Alert: Title: “Hibás év” Message: “1900-2024 között!” OK 5.6.2 Dropdown lista (Intézmény) Írd le a listát külön helyre (pl. G1:G5): G1: ELTE BTK G2: PPKE BTK G3: BME GTK Jelöld ki a célos oszlopot (E2:E100) Data → Data Validation Allow: List Source: =$G$1:$G$5 OK Előny: Nincs elgépelés, mindenki ugyanazt választja! 5.7 Gyakori hibák Vegyes típusok - Egy oszlopban szám és szöveg → rendezés hibás Összevont cellák - Megöli az adatbázis-szerűséget Üres sorok - Szűrés, Pivot nem működik jól Számok szövegként - Balra igazított, kis zöld háromszög Megoldás: Convert to Number (klikk a figyelmeztetésre) 5.8 Checklist - Jó Excel adattábla ☐ Első sor = fejléc ☐ Nincs üres sor ☐ Nincs összevont cella ☐ Egy oszlop = egy típus ☐ Atomi értékek ☐ Fejléc rögzítve (Freeze Panes) ☐ Szűrés bekapcsolva ☐ Formázás olvasható ☐ Validáció beállítva 5.9 Ellenőrző kérdések Mi a különbség a munkafüzet és a munkalap között? Hogyan navigálsz gyorsan az utolsó adathoz? (billentyű) Milyen szabályok vannak az első sorra? Miért rossz összevont cellákat használni? Mi a Freeze Panes? Mire használjuk? Hogyan állítasz be adatvalidációt? Mi a különbség a Filter és a Sort között? Mit jelent a “Table” Excelben? Hogyan illeszthetsz be csak értékeket? (Paste Special) Milyen gyakori hibákat kell elkerülni? "],["gyakorlati-példa-levéltári-nyilvántartás-készítése.html", "6 Gyakorlati példa: Levéltári nyilvántartás készítése 6.1 A feladat 6.2 Előkészületek 6.3 Fejléc sor 6.4 Adatok felvitele 6.5 Formázás 6.6 Szűrés és rendezés 6.7 Adatvalidáció 6.8 Statisztikák 6.9 Vizualizáció 6.10 Gyakori hibák 6.11 Ellenőrző kérdések", " 6 Gyakorlati példa: Levéltári nyilvántartás készítése 6.1 A feladat Digitális nyilvántartás készítése Mezők: 1. Jelzet 2. Fond megnevezése 3. Kezdő év 4. Záró év 5. Terjedelem (iratfolyóméter) 6. Raktári épület 7. Digitalizálva (Igen/Nem/Részben) 6.2 Előkészületek 6.2.1 Excel megnyitása és mentés Indítsuk el az Excelt File → Save As Név: Nyilvantartas_JELZET.xlsx Save 6.2.2 Munkalap átnevezése Dupla klikk “Sheet1” fülre (lent) Írd: Fondok Enter 6.3 Fejléc sor 6.3.1 Oszlopnevek beírása Kattints A1-re, majd írd be (Tab-bal ugorj): A1: Jelzet B1: Fond_megnevezése C1: Kezdő_év D1: Záró_év E1: Terjedelem_ifm F1: Raktári_épület G1: Digitalizálva 6.3.2 Fejléc formázása Jelöld ki A1:G1 Bold (Ctrl+B) Font size: 12 Fill Color: Világoskék Center (középre) Borders → Bottom Border 6.3.3 Oszlopszélesség Minden oszlopnál: vidd az egeret az oszlopok határára (A-B, B-C…) → Dupla klikk (automatikus szélesség) Mentés: Ctrl+S 6.4 Adatok felvitele 6.4.1 Első fond Kattints A2-re, írd be (Tab-bal tovább): A2: XXV-1 B2: Tanácsi ülések jegyzőkönyvei C2: 1950 D2: 1990 E2: 5 F2: I. épület G2: Igen Az utolsó mezőnél Enter → ugrik A3-ra (következő fond). 6.4.2 További fondok (min. 10 db) Mintaadatok: Jelzet Megnevezés Kezdő Záró Terjedelem (ifm) Raktár Digitalizálva XXVI-I-3 Magyar Állami Operaház 1945 1989 9 I. épület Igen XXVI-I-4 Állami Hangverseny- és Műsorigazgatóság 1956 1964 5 II. épület Nem XXVI-I-5 Magyar Állami Népi Együttes 1950 1986 6.6 I. épület Részben XXVI-I-6 Huszonötödik Színház 1969 1977 1.9 II. épület Nem XXVI-I-7 Állami Déryné Színház 1951 1977 4 I. épület Igen XXVI-I-8 Nemezeti Színház 1933 1997 17.85 III. épület Nem XXVI-I-9 Pesti Hírlap 1992 1984 0.72 II. épület Részben XXVI-I-10 Műcsarnok 1952 1992 14.64 I. épület Nem XXVI-I-23 Magyar Filmtudományi Intézet és Filmarchívum 1960 1977 6.2 III. épület Igen XXVI-I-65 Színház- és Filmtudományi Intézet 1957 1959 0.6 II. épület Részben Tipp: Legyünk következetesek! “I. épület” (pont után szóköz) vagy “I.épület”? Válasszunnk egyet és alkalmazzuk mindigy ugyanúgy! Mentés: Ctrl+S 6.5 Formázás 6.5.1 Table formázás Kattintsunk bárhova az adattáblán Home → Format as Table Válasszunk stílust (pl. kék) ☑ “My table has headers” OK Eredmény: - Alternatív sor színek - Szűrő nyilak (▼) - Dinamikus tábla 6.5.2 Freeze Panes Kattintsunk A2-re View → Freeze Panes → Freeze Panes Görgetéskor a fejléc látszik! Mentés: Ctrl+S 6.6 Szűrés és rendezés 6.6.1 Rendezés időrendi sorrendbe Kattintsunk “Kezdő_év” nyílra (▼) Sort Smallest to Largest 6.6.2 Szűrés - Egy épület Kattintsunk “Raktári_épület” nyílra Pipáljuk ki (Select All) Pipáljuk be csak: I. épület OK Csak I. épület fondok látszanak! Törlés: Ugyanaz a nyíl → Clear Filter 6.6.3 Komplex szűrés - Nem digitalizált, régi fondok 1. feltétel: Kezdő_év &lt; 1960 - “Kezdő_év” nyíl → Number Filters → Less Than… → 1960 → OK 2. feltétel: Digitalizálva = Nem - “Digitalizálva” nyíl → Pipáljuk be csak “Nem” → OK Eredmény: Régi, nem digitalizált fondok (2-3 db) Törlés: Data → Clear 6.7 Adatvalidáció 6.7.1 Validáció - Évek (1800-2024) Jelöljük ki C2:C100 (Kezdő_év) Data → Data Validation Settings: Allow: Whole number Data: between Minimum: 1800 Maximum: 2024 Error Alert: Title: “Hibás év” Message: “1800-2024 között!” OK Ismételd meg D2:D100-ra (Záró_év)! 6.7.2 Dropdown - Raktári épület Írd le I1:I3-ba: I1: I. épület I2: II. épület I3: III. épület Jelöld ki F2:F100 Data → Data Validation Allow: List Source: =$I$1:$I$3 OK Most dropdown lista van! 6.7.3 Dropdown - Digitalizálva Írjuk le J1:J3-ba: J1: Igen J2: Nem J3: Részben Jelöljük ki G2:G100 Data → Data Validation → List → Source: =$J$1:$J$3 → OK Mentés: Ctrl+S 6.8 Statisztikák 6.8.1 Alapstatisztikák Üres cellákba (pl. A13-tól): A13: Fondok száma: B13: =COUNTA(A2:A11) A14: Átlagos terjedelem: B14: =AVERAGE(E2:E11) A15: Legrégebbi: B15: =MIN(C2:C11) A16: Legfiatalabb: B16: =MAX(C2:C11) 6.8.2 Feltételes számolás A17: Digitalizált (Igen): B17: =COUNTIF(G2:G11,&quot;Igen&quot;) A18: Részben: B18: =COUNTIF(G2:G11,&quot;Részben&quot;) A19: Nem digitalizált: B19: =COUNTIF(G2:G11,&quot;Nem&quot;) Mentés: Ctrl+S 6.9 Vizualizáció 6.9.1 Pivot tábla - Épületek szerinti megoszlás Kattintunk az adattáblán Insert → PivotTable New Worksheet → OK Pivot Fields panel (jobbra): Húzzuk “Raktári_épület” → Rows Húzzuk “Raktári_épület” → Values Eredmény: Raktári_épület Count I. épület 4 II. épület 3 III. épület 2 6.9.2 Grafikon Kattintunk a Pivot táblára Insert → Column Chart Válasszuk oszlopdiagramot Testreszabás: - Chart Title: “Fondok megoszlása raktári épületek szerint” 6.9.3 Munkalap átnevezése Dupla klikk “Sheet1” fülre → Írjuk be: Statisztika Mentés: Ctrl+S (utoljára!) 6.10 Gyakori hibák Szűrés nem működik → Üres sorok vannak Validáció nincs → Rossz tartomány COUNTA rossz → Fejléc benne van a tartományban Freeze Panes nem működik → Rossz cellán állunk (A2 kell!) Miről volt szó ebben a részben: 1. Strukturált tábla (fejléc, sorok, nincs üres) 2. Formázás (Table, Freeze Panes) 3. Szűrés és rendezés 4. Adatvalidáció (számok, dropdown) 5. Statisztikák (COUNTA, COUNTIF, AVERAGE) 6. Vizualizáció (Pivot, grafikon) 6.11 Ellenőrző kérdések Miért fontos az első sor fejléc? Miért rossz összevont cellákat használni? Hogyan állíthatunk be dropdown listát? Mi a különbség a Filter és a PivotTable között? Hogyan rögzíthetjük a fejléc sort? Milyen képlet számolja a rekordokat? Milyen képlet számolja a “Igen” értékeket? Miért fontos a konzisztencia az adatbevitelnél? Hogyan szűrhetünk egyszerre több feltétel szerint? "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
